Week11 commands [Veer Singh]

>>> username: root
>>> password: INBMA0634L

Generating key pair with openssl
>>> openssl genpkey -algorithm RSA -out key.pem -pkeyopt rsa_keygen_bits:2048
>>> openssl rsa -in key.pem -out key.pub.pem -pubout
>>> ls -al
Now we have a public and private key

Now we create a document and sign it with a private key
>>> echo Some text to sign. >document
>>> cat document
We create this file called document with the contents "Some text to sign."

We will use SHA hash value for the document
>>> openssl dgst -sign key.pem -out document.sign -sha256 document
>>> ls -la
we see that the document.sign file appears with exactly 256 bytes
>>> xxd document.sign
We can also see the encrypted data in hex format

Now with the original document, and the hash value assigned to the document and the public key anyone can verify the signature
>>> openssl dgst -verify key.pub.pem -sha256 -signature document.sign document
We will get a Verified OK message

Lets try to change the document
>>> vi document
We change "Some text to sign." to "Some text to sign!" in the vi editor. (Note: Use "i" to enter insert mode, "esc" to stop insert mode, ":wq" to save and quit)
>>> cat document
We did not generate new signature, now the verification should fail since the current document is not the one we signed
>>> openssl dgst -verify key.pub.pem -sha256 -signature document.sign document
We get a message Verification Failure

----------------------------------
>>> openssl pkcs8 -topk8 -in key.pem -out key.enc.pem
>>> 1234
>>> 1234
>>> cat key.pem
>>> cat key.enc.pem
>>> openssl dgst -sign key.enc.pem -out document.sign -sha256 document
>>> 1234
Now we sign the new document with the "!" at the end 
>>> openssl dgst -verify key.pub.pem -sha256 -signature document.sign document
We get a Verified OK message

The private key always stores information about the public key. We can generate a public key
>>> openssl rsa -in key.pem -out key.2.pem
>>> cat key.2.pem
Copy the entire output by selecting it in the terminal.
Paste this into a text file and name it "key.txt"
Now open PuTTygen -> File -> Load private key -> Change filter to All Files -> Navigate to the key.txt -> Open
Now we can see the extracted public key in the window.
We can check its the same by
>>> cat key.pub.pem

----------------------------------------------
Changing the password of root user
-> Start the virtual machine in normal mode
-> Press the up or down arrow key as soon as boot screen appears
-> Select the first option and press "e"
-> add 'rd.break' before 'ro' in the fifth line
-> ctrl + x to execute
-> an emergency console will appear, now we have root priveledges
-> Still passwd is not working so we cant yet change the root user password
>>> mount 
-> Issuing this command tells us that sda1 is mounted on /sysroot (last line)
>>> mount -o remount,rw /sysroot/
>>> chroot /sysroot/
-> we get a new shell
>>> /bin/passwd
>>> 1234
>>> 1234
-> Now we have set the password of root to 1234, but we have to make some more changes before we can login with this password, we need to ask the system to do some relabeling
>>> touch /.autorelabel
>>>exit
>>> reboot
The relabeling process will take some time. The system will also reboot once
>>> username: root
>>> password: 1234
And now we are able to login with this new password

--------------------------------
Close the last virtualmachine and restart it in headless mode and then connect with PuTTy
>>> username: root
>>> password: 1234

We want to install a http web server on this machine
>>> dnf install httpd
>>> vi /etc/httpd/conf/httpd.conf
We can see some useful infomation about the web server here. (':q' to quit)
>>> echo HELLO >/var/www/html/hello.txt
We add this 
>>> systemctl start httpd
>>> systemctl status httpd
We start the sevrer, and see its status
>>> firewall-cmd --list-services
We can list the services, by default 3 are active
>>> firewall-cmd --add-service http
>>> firewall-cmd --list-services
We can add a service
These changes are not permanent, if we want to execute them automatically on boot time we have to enable it
>>> systemctl enable httpd
>>> firewall-cmd --permanent --add-service http

Note if we want to use a port on a virtual machine, we need to map this port to a non virtual port on the host machine.
Open Virtualbox -> Select the virtual machine -> Settings -> Network -> Advanced -> Port forwarding -> Add -> Change Host Port to 80 and Guest Port to 80 -> Ok -> Ok
Now we are able to use the web server
Open any browser -> http://localhost/hello.txt -> We get a website with the text 'HELLO' (As shown in the image in main PDF)

>>> stat /var/www/html/hello.txt
When we check the permissions of this file we see that its 644, read write on owner and read on group and others (this is the default settings). Now we need to change it so that it is not accessible by anyone else
Chmod is a good option but we want to change the default settings. To change this we change the umask
>>> umask
Currently the umask is 022, if we change it to 077 then the defaults will be 600
>>> umask 077
Now we create another txt file
>>> echo "Something" >/var/www/html/hello2.txt
>>> stat /var/www/html/hello2.txt
Now we can see the permissions are 600, only owner can read it.
Now open the browser -> http://localhost/hello2.txt -> we get an error saying we cannot access this (shown as an image in the main PDF)

We can change the owner to apache
>>> chown apache /var/www/html/hello2.txt
>>> stat /var/www/html/hello2.txt
Now if we open the same link on the browser -> http://localhost/hello2.txt -> We are able to see the text 'Something' (shown as an image in the main PDF)
This is because apache is the web server